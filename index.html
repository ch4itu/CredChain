<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CredChain - Credential Issuance & Verification</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f9f9f9; margin: 0; padding: 20px; }
    .container { max-width: 800px; margin: auto; background: #fff; padding: 20px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    .section { border: 1px solid #ccc; padding: 20px; margin-bottom: 20px; }
    label { display: block; margin-top: 10px; }
    input, textarea, select, button { width: 100%; padding: 8px; margin-top: 4px; }
    button { margin-top: 10px; }
    #qrCode, #video { margin-top: 20px; }
    /* Hide the verification result page initially */
    #verificationResultPage { display: none; }
  </style>
  <!-- Include dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrious@4.0.2/dist/qrious.min.js"></script>
  <!-- Include ZXing library for QR scanning -->
  <script src="https://unpkg.com/@zxing/library@latest"></script>
</head>
<body>
  <div class="container">
    <h1>CredChain - Credential Issuance & Verification</h1>
    
    <!-- Issuance Section -->
    <div id="issuancePage" class="section">
      <h2>Issue Credential</h2>
      <form id="issueForm">
        <label for="mnemonic">Issuer Wallet Mnemonic (Authorized Issuer Only):</label>
        <input type="text" id="mnemonic" required placeholder="Enter your wallet mnemonic">
        
        <label for="name">Name:</label>
        <input type="text" id="name" required>
        
        <label for="dob">Date of Birth:</label>
        <input type="date" id="dob" required>
        
        <label for="semester">Semester:</label>
        <input type="text" id="semester" required>
        
        <label for="subjects">Subjects (comma separated):</label>
        <input type="text" id="subjects" required>
        
        <label for="marks">Marks (comma separated corresponding to subjects):</label>
        <input type="text" id="marks" required>
        
        <label for="photo">Upload Photo:</label>
        <input type="file" id="photo" accept="image/*" required>
        
        <button type="submit">Submit & Issue Credential</button>
      </form>
      <div id="issuanceStatus"></div>
      <div id="qrCode"></div>
    </div>
    
    <!-- Verification Scanning Section -->
    <div id="verificationSection" class="section">
      <h2>Verify Credential</h2>
      <button id="startScan">Start Camera QR Code Scan</button>
      <br><br>
      <label for="qrUpload">Or upload a QR Code image:</label>
      <input type="file" id="qrUpload" accept="image/*">
    </div>
    
    <!-- Verification Result Page (initially hidden) -->
    <div id="verificationResultPage" class="section">
      <h2>Verification Result</h2>
      <div id="credentialDisplay"></div>
      <div id="verificationMessage" style="font-weight: bold; margin-top: 10px;"></div>
      <button id="backToScan">Back to Scan</button>
    </div>
  </div>
  
  <script>
    // ----- Configuration -----
    // The destination address is set to the dead address.
    const DESTINATION_ADDRESS = "0x000000000000000000000000000000000000dEaD";
    // Polygon RPC endpoint.
    const rpcEndpoint = "https://polygon-rpc.com";

    // ----- Utility Functions -----

    // Compute SHA-256 hash using the Web Crypto API.
    async function computeSHA256(message) {
      const encoder = new TextEncoder();
      const data = encoder.encode(message);
      const hashBuffer = await crypto.subtle.digest("SHA-256", data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return "0x" + hashArray.map(b => b.toString(16).padStart(2, "0")).join("");
    }

    // Compress image to under targetKB (in kilobytes) and return a Base64 string.
    function compressImage(file, targetKB, callback) {
      const reader = new FileReader();
      reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          const maxDim = 100; // Adjust as needed.
          let width = img.width;
          let height = img.height;
          if (width > height) {
            if (width > maxDim) {
              height = Math.round(height * (maxDim / width));
              width = maxDim;
            }
          } else {
            if (height > maxDim) {
              width = Math.round(width * (maxDim / height));
              height = maxDim;
            }
          }
          canvas.width = width;
          canvas.height = height;
          ctx.drawImage(img, 0, 0, width, height);
          let quality = 0.9;
          const minQuality = 0.1;
          function tryCompress() {
            canvas.toBlob(function(blob) {
              if (!blob) { callback(null); return; }
              const sizeKB = blob.size / 1024;
              console.log(`Compressed size: ${sizeKB.toFixed(2)} KB at quality ${quality}`);
              if (sizeKB <= targetKB || quality <= minQuality) {
                const reader2 = new FileReader();
                reader2.onloadend = function() { callback(reader2.result); };
                reader2.readAsDataURL(blob);
              } else { quality -= 0.1; tryCompress(); }
            }, "image/jpeg", quality);
          }
          tryCompress();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    // ----- Issuance Logic -----
    document.getElementById("issueForm").addEventListener("submit", async function(event) {
      event.preventDefault();
      document.getElementById("issuanceStatus").innerText = "Processing...";

      // Collect form data.
      const mnemonic = document.getElementById("mnemonic").value.trim();
      const name = document.getElementById("name").value.trim();
      const dob = document.getElementById("dob").value;
      const semester = document.getElementById("semester").value.trim();
      const subjects = document.getElementById("subjects").value.trim().split(",");
      const marks = document.getElementById("marks").value.trim().split(",");
      const photoFile = document.getElementById("photo").files[0];
      if (!photoFile) {
        document.getElementById("issuanceStatus").innerText = "Please upload a photo.";
        return;
      }

      // Compress the image to under 2 KB.
      compressImage(photoFile, 2, async function(photoBase64) {
        if (!photoBase64) {
          document.getElementById("issuanceStatus").innerText = "Error compressing image.";
          return;
        }

        // Prepare JSON data.
        const dataObject = { name, dob, semester, subjects, marks, photo: photoBase64 };
        const jsonData = JSON.stringify(dataObject);

        // Compute SHA-256 hash of the JSON data.
        const dataHash = await computeSHA256(jsonData);
        console.log("Computed Data Hash:", dataHash);

        try {
          // Create a wallet from the mnemonic.
          const wallet = ethers.Wallet.fromMnemonic(mnemonic);
          // The authorized address is derived from the mnemonic.
          const authorizedAddress = wallet.address;
          console.log("Authorized Address:", authorizedAddress);

          // Connect the wallet to the provider.
          const provider = new ethers.providers.JsonRpcProvider(rpcEndpoint);
          const signer = wallet.connect(provider);

          // Build the transaction object.
          const txObj = { to: DESTINATION_ADDRESS, value: 0, data: dataHash, from: authorizedAddress };

          // Try to estimate gas.
          let estimatedGas;
          try {
            estimatedGas = await provider.estimateGas(txObj);
            console.log("Estimated Gas:", estimatedGas.toString());
          } catch (gasError) {
            console.warn("Gas estimation failed, using fallback gas limit. Error:", gasError.message);
            estimatedGas = ethers.BigNumber.from("200000");
          }

          // Retrieve current gas price and boost it by 20%.
          const currentGasPrice = await provider.getGasPrice();
          const boostedGasPrice = currentGasPrice.mul(120).div(100);
          console.log("Boosted Gas Price:", boostedGasPrice.toString());

          // Send a legacy (type 0) transaction with the boosted gas price.
          const tx = await signer.sendTransaction({
            ...txObj,
            type: 0,
            gasLimit: estimatedGas,
            gasPrice: boostedGasPrice
          });

          document.getElementById("issuanceStatus").innerText = "Transaction sent. Waiting for confirmation...";
          console.log("Transaction sent:", tx.hash);

          // Wait for transaction confirmation.
          const receipt = await tx.wait();
          console.log("Transaction confirmed:", receipt.transactionHash);
          document.getElementById("issuanceStatus").innerText = "Credential issued. Transaction ID: " + receipt.transactionHash;

          // Generate a QR code that embeds the issuer, JSON data, and transaction ID.
          const qrData = { issuer: authorizedAddress, data: dataObject, txId: receipt.transactionHash };
          // Updated QRious options: setting error correction level to "L" and adding padding.
          const qr = new QRious({
            element: document.createElement("canvas"),
            value: JSON.stringify(qrData),
            size: 400,
            level: "L",       // Lower error correction level for a less dense QR code
            padding: 10       // Add padding to improve scannability
          });
          const qrDiv = document.getElementById("qrCode");
          qrDiv.innerHTML = "";
          qrDiv.appendChild(qr.element);
        } catch (error) {
          console.error("Error during issuance:", error);
          document.getElementById("issuanceStatus").innerText = "Error: " + error.message;
        }
      });
    });

    // ----- Verification Logic -----
    // Function to process a decoded QR code (from camera scan or file upload)
    async function processDecodedQrCode(decodedText) {
      try {
        // Expected JSON object with properties: issuer, data, and txId.
        const qrData = JSON.parse(decodedText);
        const scannedData = JSON.stringify(qrData.data);
        const scannedTxId = qrData.txId;
        const expectedIssuer = qrData.issuer;

        // Compute the hash of the scanned JSON data.
        const computedHash = await computeSHA256(scannedData);
        console.log("Computed Hash from Scanned Data:", computedHash);

        // Retrieve the transaction from the blockchain.
        const provider = new ethers.providers.JsonRpcProvider(rpcEndpoint);
        const tx = await provider.getTransaction(scannedTxId);
        if (!tx) {
          showVerificationResult("Transaction not found on Polygon PoS Chain.", null);
          return;
        }
        console.log("Retrieved Transaction:", tx);

        // Verify that the transaction originates from the expected issuer.
        let verificationMessage = "";
        if (tx.from.toLowerCase() !== expectedIssuer.toLowerCase()) {
          verificationMessage = "Verification Failed: Transaction not from the expected issuer.";
        } else if (tx.data.toLowerCase() !== computedHash.toLowerCase()) {
          verificationMessage = "Verification Failed: Data mismatch.";
        } else {
          verificationMessage = "Verification Successful: Data is authentic.";
        }
        // Display the scanned credential data along with verification result.
        showVerificationResult(verificationMessage, qrData.data);
      } catch (error) {
        console.error("Error during verification:", error);
        showVerificationResult("Error: " + error.message, null);
      }
    }

    // Function to display verification result on a separate page (within the same HTML)
    function showVerificationResult(message, credentialData) {
      let dataHtml = "";
      if (credentialData) {
        dataHtml += "<h3>Credential Data</h3>";
        dataHtml += `<p><strong>Name:</strong> ${credentialData.name}</p>`;
        dataHtml += `<p><strong>Date of Birth:</strong> ${credentialData.dob}</p>`;
        dataHtml += `<p><strong>Semester:</strong> ${credentialData.semester}</p>`;
        dataHtml += `<p><strong>Subjects:</strong> ${credentialData.subjects.join(", ")}</p>`;
        dataHtml += `<p><strong>Marks:</strong> ${credentialData.marks.join(", ")}</p>`;
        dataHtml += `<p><strong>Photo:</strong><br><img src="${credentialData.photo}" alt="Credential Photo" style="max-width:300px;"></p>`;
      }
      document.getElementById("credentialDisplay").innerHTML = dataHtml;
      document.getElementById("verificationMessage").innerText = message;
      document.getElementById("verificationSection").style.display = "none";
      document.getElementById("verificationResultPage").style.display = "block";
    }

    // QR Code scanning via camera using ZXing.
    document.getElementById("startScan").addEventListener("click", function() {
      const codeReader = new ZXing.BrowserMultiFormatReader();
      codeReader.listVideoInputDevices()
        .then(videoInputDevices => {
          const firstDeviceId = videoInputDevices[0].deviceId;
          codeReader.decodeFromVideoDevice(firstDeviceId, "video", (result, err) => {
            if (result) {
              console.log("Camera scan result:", result.getText());
              codeReader.reset();
              processDecodedQrCode(result.getText());
            }
            if (err && !(err instanceof ZXing.NotFoundException)) {
              console.error(err);
            }
          });
        })
        .catch(err => console.error(err));
    });

    // QR Code decoding from an uploaded image using ZXing.
    document.getElementById("qrUpload").addEventListener("change", function(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const img = new Image();
        img.onload = function() {
          const codeReader = new ZXing.BrowserMultiFormatReader();
          codeReader.decodeFromImage(img)
            .then(result => {
              console.log("File scan result:", result.getText());
              processDecodedQrCode(result.getText());
            })
            .catch(err => {
              console.error("Error decoding QR code from file:", err);
              document.getElementById("verificationResult").innerText = "QR Code not detected in the uploaded image.";
            });
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    });

    // "Back to Scan" button functionality to return to scanning page.
    document.getElementById("backToScan").addEventListener("click", function() {
      document.getElementById("verificationResultPage").style.display = "none";
      document.getElementById("verificationSection").style.display = "block";
      document.getElementById("verificationResult").innerText = "";
    });
  </script>
  
  <!-- Video element for camera scanning (used by ZXing) -->
  <video id="video" style="width:300px; display: none;"></video>
  
  <!-- Hidden div for verification result display -->
  <div id="verificationResultPage" class="section" style="display: none;">
    <h2>Verification Result</h2>
    <div id="credentialDisplay"></div>
    <div id="verificationMessage" style="font-weight: bold; margin-top: 10px;"></div>
    <button id="backToScan">Back to Scan</button>
  </div>
</body>
</html>

